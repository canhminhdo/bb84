fmod BIT is
    sort Bit .
    ops 0 1 : -> Bit [ctor] .
endfm

fmod BASIS is
    sort Basis .
    ops + x : -> Basis [ctor] .
endfm

fmod QUBIT is
    pr BIT .
    pr BASIS .
    sort Qubit  .
    op qubit : Bit Basis -> Qubit [ctor] .
endfm

fmod ACK is
    sort Ack .
    ops ok notOk : -> Ack [ctor] .
endfm

fmod KNOWLEDGE is
    pr QUBIT .
    pr NAT .
    pr ACK .

    sorts KeyIdx BasisIdx AckIdx Knowledge .
    subsorts KeyIdx BasisIdx AckIdx < Knowledge .
    
    op key : Bit Nat -> KeyIdx [ctor] .
    op basis : Basis Nat -> BasisIdx [ctor] .
    op ack : Ack Nat -> AckIdx [ctor] .
    op emp : -> Knowledge [ctor] .
    op __ : Knowledge Knowledge -> Knowledge [ctor comm assoc id: emp] .

    --- check if the key is already in the knowledge    
    var N : Nat .
    var K : Bit .
    var KL : Knowledge .
    op existKeyByIdx : Knowledge Nat -> Bool .
    eq existKeyByIdx(key(K, N) KL, N) = true .
    eq existKeyByIdx(KL, N) = false [owise] .
endfm

view BasisIdx from TRIV to KNOWLEDGE is
    sort Elt to BasisIdx .
endv

view Qubit from TRIV to QUBIT is
    sort Elt to Qubit .
endv

view Ack from TRIV to ACK is
    sort Elt to Ack .
endv

fmod ILIST {D :: TRIV} is
    pr NAT .
    sort IList{D} .
    subsort D$Elt < IList{D} .
    op nil : -> IList{D} [ctor] .
    op _|_ : IList{D} IList{D} -> IList{D} [ctor assoc id: nil] .
endfm

fmod SOUP {D :: TRIV} is
  sort Soup{D} .
  subsort D$Elt < Soup{D} .
  op empty : -> Soup{D} [ctor] .
  op __ : Soup{D} Soup{D} -> Soup{D} [ctor assoc comm id: empty] .
endfm

fmod STATUS is
    sort Status .
    ops idle init exchange discuss : -> Status [ctor] .
    ops aInitKey aInitBasis : -> Status [ctor] .
    ops eInitBasis bInitBasis : -> Status [ctor] .
endfm

fmod OCOMP is
    pr KNOWLEDGE .
    pr STATUS .
    pr ILIST{Qubit} .
    pr ILIST{BasisIdx} .
    pr ILIST{Ack} .
    pr NAT .

    sort OComp .

    op (alice:_) : Knowledge -> OComp [ctor] .
    op (bob:_) : Knowledge -> OComp [ctor] .
    op (eva:_) : Knowledge -> OComp [ctor] .
    op (ch:_) : IList{Qubit} -> OComp [ctor] .
    op (a2b:_) : IList{Ack} -> OComp [ctor] .
    op (b2a:_) : IList{BasisIdx} -> OComp [ctor] .
    op (status:_) : Status -> OComp [ctor] .
    op (cnt:_) : Nat -> OComp [ctor] .
endfm

view OComp from TRIV to OCOMP is
    sort Elt to OComp .
endv

fmod OCOMP-SOUP is
    pr SOUP{OComp} .
endfm

fmod CONFIG is
    pr OCOMP-SOUP .
    sorts Config .
    op {_} : Soup{OComp} -> Config [ctor] .
    ops init init2 init3 init4 init5 init10 init15 init20 : -> Config .
    eq init = { (cnt: 1) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
    eq init2 = { (cnt: 2) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
    eq init3 = { (cnt: 3) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
    eq init4 = { (cnt: 4) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
    eq init5 = { (cnt: 5) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
    eq init10 = { (cnt: 10) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
    eq init15 = { (cnt: 15) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
    eq init20 = { (cnt: 20) (alice: emp) (eva: emp) (bob: emp) (status: idle) (ch: nil) (b2a: nil) (a2b: nil) } .
endfm

mod BB84 is
    pr CONFIG .

    var OCs : Soup{OComp} .
    vars N N' : Nat .
    vars AK BK EK : Knowledge .
    vars K K' : Bit .
    vars B B' : Basis .
    vars ACK : Ack .
    
    --- initialization
    crl [init] : { (status: idle) (cnt: N) OCs } 
    => { (status: aInitKey) (cnt: N) OCs } if N > 0 .

    --- Alice inits key
    rl [aInitKey0] : { (status: aInitKey) (alice: AK) (cnt: N) OCs }
    => { (status: aInitBasis) (alice: (key(0, N) AK)) (cnt: N) OCs } .

    rl [aInitKey1] : { (status: aInitKey) (alice: AK) (cnt: N) OCs }
    => { (status: aInitBasis) (alice: (key(1, N) AK)) (cnt: N) OCs } .

    --- Alice inits basis
    rl [aInitBasis1] : { (status: aInitBasis) (alice: AK) (cnt: N) OCs }
    => { (status: bInitBasis) (alice: (basis(+, N) AK)) (cnt: N) OCs } .

    rl [aInitBasis2] : { (status: aInitBasis) (alice: AK) (cnt: N) OCs }
    => { (status: bInitBasis) (alice: (basis(x, N) AK)) (cnt: N) OCs } .

    --- bob init basis
    rl [bInitBasis1] : { (status: bInitBasis) (bob: BK) (cnt: N) OCs }
    => { (status: eInitBasis) (bob: (basis(+, N) BK)) (cnt: N) OCs } .

    rl [bInitBasis2] : { (status: bInitBasis) (bob: BK) (cnt: N) OCs }
    => { (status: eInitBasis) (bob: (basis(x, N) BK)) (cnt: N) OCs } .

    --- eva init basis 
    rl [eInitBasis1] : { (status: eInitBasis) (eva: EK) (cnt: N) OCs }
    => { (status: exchange) (eva: (basis(+, N) EK)) (cnt: N) OCs } .

    rl [eInitBasis2] : { (status: eInitBasis) (eva: EK) (cnt: N) OCs }
    => { (status: exchange) (eva: (basis(x, N) EK)) (cnt: N) OCs } .

    --- alice sends a qubit
    rl [aSend] : 
    { (status: exchange) (ch: nil) (alice: (key(K, N) basis(B, N) AK)) (cnt: N) OCs }
    => { (status: exchange) (ch: qubit(K, B)) (alice: (key(K, N) basis(B, N) AK)) (cnt: N) OCs } .

    --- eva intercepts and resends the qubit
    crl [eSameBasis] :
    { (status: exchange) (ch: qubit(K, B)) (eva: (basis(B, N) EK)) (cnt: N) OCs }
    => { (status: exchange) (ch: qubit(K, B)) (eva: (key(K, N) basis(B, N) EK)) (cnt: N) OCs } 
    if not existKeyByIdx(EK, N) .

    crl [eNotSameBasis1] :
    { (status: exchange) (ch: qubit(K, B)) (eva: (basis(B', N) EK)) (cnt: N) OCs }
    => { (status: exchange) (ch: qubit(0, B')) (eva: (key(0, N) basis(B', N) EK)) (cnt: N) OCs } 
    if not existKeyByIdx(EK, N)
    /\ B =/= B' .

    crl [eNotSameBasis2] :
    { (status: exchange) (ch: qubit(K, B)) (eva: (basis(B', N) EK)) (cnt: N) OCs }
    => { (status: exchange) (ch: qubit(1, B')) (eva: (key(1, N) basis(B', N) EK)) (cnt: N) OCs } 
    if not existKeyByIdx(EK, N)
    /\ B =/= B' .
    
    --- bob measures the qubit
    rl [bSameBasis] :
    { (status: exchange) (ch: qubit(K, B)) (bob: (basis(B, N) BK)) (cnt: N) OCs }
    => { (status: discuss) (ch: nil) (bob: (key(K, N) basis(B, N) BK)) (cnt: N) OCs } .
    
    crl [bNotSameBasis1] :
    { (status: exchange) (ch: qubit(K, B)) (bob: (basis(B', N) BK)) (cnt: N) OCs }
    => { (status: discuss) (ch: nil) (bob: (key(0, N) basis(B', N) BK)) (cnt: N) OCs } 
    if B =/= B' .

    crl [bNotSameBasis2] :
    { (status: exchange) (ch: qubit(K, B)) (bob: (basis(B', N) BK)) (cnt: N) OCs }
    => { (status: discuss) (ch: nil) (bob: (key(1, N) basis(B', N) BK)) (cnt: N) OCs } 
    if B =/= B' .

    --- bob sends (basis, index) to alice
    rl [bAnnounce] :
    { (status: discuss) (b2a: nil) (a2b: nil) (bob: (basis(B, N) BK)) (cnt: N) OCs }
    => { (status: discuss) (b2a: basis(B, N)) (a2b: nil) (bob: (basis(B, N) BK)) (cnt: N) OCs } .

    --- alice sends acknowledgment to bob
    crl [aliceAck] :
    { (status: discuss) (b2a: basis(B, N)) (a2b: nil) (alice: (basis(B', N) AK)) (cnt: N) OCs }
    =>  { (status: discuss) (b2a: basis(B, N)) (a2b: ACK) (alice: (ack(ACK, N) basis(B', N) AK)) (cnt: N) OCs } 
    if ACK := (if B == B' then ok else notOk fi).
    
    --- bob confirms acknowledgment from bob
    rl [bConfirmAck] :
    { (status: discuss) (b2a: basis(B, N)) (a2b: ACK) (bob: (basis(B, N) BK)) (cnt: N) OCs }
    =>  { (status: idle) (b2a: nil) (a2b: nil) (bob: (ack(ACK, N) basis(B, N) BK)) (cnt: sd(N, 1)) OCs } .

    rl [stutter] : { (cnt: 0) OCs } => { (cnt: 0) OCs } .
endm

sload model-checker

mod BB84-PREDS is
    protecting BB84 .
    including SATISFACTION .
    
    subsort Config < State .
    
    op isEnd : -> Prop [ctor] .
    op evaPresent : Nat -> Prop [ctor] .
    op sameBasis : Nat -> Prop [ctor] .
    op sameKey : Nat -> Prop [ctor] .
    op evaSameBasis : Nat -> Prop [ctor] .
    
    var Idx : Nat .
    var OCs : Soup{OComp} .
    vars AK BK EK : Knowledge .
    vars B B' : Basis .
    vars K K' : Bit .

    eq { (eva: (key(K, Idx) EK)) OCs } |= evaPresent(Idx) = true .
    eq { OCs } |= evaPresent(Idx) = false [owise] .

    eq { (alice: (basis(B, Idx) AK)) (bob: (basis(B, Idx) BK)) OCs } |= sameBasis(Idx) = true .
    eq { OCs } |= sameBasis(Idx) = false [owise] .
    
    eq { (alice: (key(K, Idx) AK)) (bob: (key(K, Idx) BK)) OCs } |= sameKey(Idx) = true .
    eq { OCs } |= sameKey(Idx) = false [owise] .

    eq { (alice: (basis(B, Idx) AK)) (eva: (basis(B, Idx) EK)) OCs } |= evaSameBasis(Idx) = true .
    eq { OCs } |= evaSameBasis(Idx) = false [owise] .
    
    eq { (cnt: 0) OCs } |= isEnd = true .
    eq { OCs } |= isEnd = false [owise] .

endm

mod BB84-FORMULAE is
    pr BB84-PREDS .
    pr MODEL-CHECKER .
    
    var N : Nat .

    op keyAgreement : Nat -> Formula .
    eq keyAgreement(0) = True .
    ceq keyAgreement(N) = keyAgreement(sd(N, 1)) /\ (sameBasis(N) /\ ([] ~ evaPresent(N))) |-> sameKey(N) if N > 0 .

    op evaNotDetected : Nat -> Formula .
    eq evaNotDetected(0) = True .
    ceq evaNotDetected(N) = evaNotDetected(sd(N, 1)) /\ (sameBasis(N) /\ <> evaPresent(N)) |-> sameKey(N) if N > 0 .
endm

mod BB84-CHECK is
    protecting BB84-FORMULAE . 
    including MODEL-CHECKER .
endm

--- red in BB84-CHECK : modelCheck(init2, (sameBasis(1) /\ ([] ~ evaPresent(1))) |-> sameKey(1) ) .
--- red in BB84-CHECK : modelCheck(init2, (sameBasis(2) /\ ([] ~ evaPresent(2))) |-> sameKey(2) ) .
--- red in BB84-CHECK : modelCheck(init2, (sameBasis(1) /\ (<> (evaPresent(1) /\ evaSameBasis(1)))) |-> sameKey(1) ) .
--- red in BB84-CHECK : modelCheck(init2, (sameBasis(1) /\ <> evaPresent(1)) |-> sameKey(1) ) .
red in BB84-CHECK : modelCheck(init2, keyAgreement(2)) .
red in BB84-CHECK : modelCheck(init2, evaNotDetected(2)) .

--- search in BB84 : init2 =>! C:Config .
--- umaudemc check bb84.maude init2 'E <> evaDetected(2)'
--- umaudemc check bb84.maude init2 '(A E ~ evaCorrectAll(2)) -> E <> evaDetected(2)'
--- umaudemc pcheck bb84.maude init2 '<> endAll' 
--- umaudemc pcheck bb84.maude init2 '<> evaDetected(2)'
--- umaudemc pcheck bb84.maude init3 '<> evaDetected(3)'
--- umaudemc pcheck bb84.maude init4 '<> evaDetected(4)'
--- umaudemc pcheck bb84.maude init5 '<> evaDetected(5)'